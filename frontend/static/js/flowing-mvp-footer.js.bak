// Backup of flowing-mvp-footer.js ‚Äî created before mass comment cleanup
// Full original snapshot preserved for review.
// DO NOT EDIT THIS FILE - it's an automatic backup of the original source.

// Flowing MVP Footer JS

/**
 * FLOWING MVP FOOTER
 * Collapsible chat assistant with context awareness
 */

// Flowing MVP Footer script
// ============================================================
// SECTION: FILE ORGANIZATION MARKERS
// This file is organized into clearly marked sections to aid
// navigation and reviews. Sections (in-order):
//  A) Header / Metadata
//  B) Utilities / Helpers
//  C) FlowingFooter class (constructor & state)
//  D) Event listeners & DOM wiring
//  E) Rendering & Balanced view handling
//  F) SLA & Attachments handling
//  G) Initialization & global compatibility shims
// ============================================================

// === SECTION C: FlowingFooter class (constructor & state) ===
class FlowingFooter {
	constructor() {
		this.footer = null;
		this.toggleBtn = null;
		this.messagesContainer = null;
		this.input = null;
		this.sendBtn = null;
		this.contextBadge = null;
		this.suggestionElement = null;
		this.root = null;
		this.headerEl = null;
		this.balancedView = null;
		this.balancedContentContainer = null;
		this.toggleHit = null;
		this.footerCommentText = null;
		this.attachBtn = null;
		this.attachmentsPreview = null;
		this.attachmentsListFooter = null;
		this.attachmentsListRight = null;
		this.attachmentsListHeader = null;
		this.kanbanView = null;
		this.isExpanded = false;
		this.isLoading = false;
		this.context = {
			currentDesk: null,
			currentQueue: null,
			selectedIssue: null,
			viewMode: 'kanban'
		};
		this.suggestions = [];
		this.currentSuggestionIndex = 0;
		this.suggestionInterval = null;
		this.lastAnalyzeAt = 0;
		this.suggestionPaused = false;

		this.init();
	}


	// === SECTION B: Utilities / Helper Methods ===
	// Utility: strip HTML tags and normalize whitespace for stable comparisons
	_stripHTML(text = '') {
		try {
			return (text + '').replace(/<[^>]*>/g, '').replace(/\s+/g, ' ').trim();
		} catch (e) { return (text || '').toString(); }

		// Set initial padding
		this.adjustContentPadding(true); // Start collapsed

		// Ensure balanced view is present in the DOM (must be provided by templates)
		if (!this.balancedView) {
			console.error('‚ùå Balanced view not found');
			return;
		}

		// Ensure header exists ‚Äî avoid changing attributes that other modules
		// may rely on (do NOT remove `hidden` or overwrite `aria-hidden`).
		// Only touch inline styles minimally to avoid surprising overrides.
		if (this.headerEl) {
			try {
				// Do not forcibly remove attributes set by other modules. Keep
				// attribute-level state intact; prefer class/style-only changes.
				// Ensure header uses flex layout to match markup and remain visible.
				this.headerEl.style.display = this.headerEl.style.display || 'flex';
				this.headerEl.style.visibility = this.headerEl.style.visibility || 'visible';
			} catch (e) { /* ignore */ }
		}

		// Ensure the header element is a child of the footer so it inherits
		// footer attributes and positioning (prevents it being rendered as a
		// page-top banner if moved elsewhere).
		try {
			if (this.headerEl && this.footer && this.headerEl.parentElement !== this.footer) {
				this.footer.insertBefore(this.headerEl, this.footer.firstChild);
			}
		} catch (e) { /* ignore */ }

		// Start collapsed (only header + suggestions)
		try { this.collapse(); } catch (e) { /* ignore */ }

		console.log('‚úÖ Flowing MVP ready');
	}

	attachEventListeners() {
		// Simplified toggle: only expand/collapse balanced view
		try {
			// Prefer the explicit toggle button, fallback to a hit area
			const btn = document.getElementById('flowingToggleBtn') || document.getElementById('flowingToggleHit');
			if (!btn) return;
			this.toggleBtn = btn;
	async renderBalancedContent(issue) {
				try {
					// Delegate to extracted module (authoritative) when available
					if (window.balancedViewRenderer && typeof window.balancedViewRenderer.renderBalancedContent === 'function') {
						return await window.balancedViewRenderer.renderBalancedContent(issue);
					}
					// Final attempt: dynamic import
					try {
						const mod = await import('/static/js/modules/balanced-view-renderer.js?v=' + Date.now());
						if (mod && typeof mod.renderBalancedContent === 'function') {
							return await mod.renderBalancedContent(issue);
						}
					} catch (e) { console.warn('Could not dynamically import balanced-view-renderer module', e); }
					console.warn('Balanced view renderer unavailable; skipping renderBalancedContent');
				} catch (e) { console.warn('renderBalancedContent wrapper error', e); }
			}
			this.footer.style.setProperty('--flowing-footer-overlay-top', safeTop + 'px');
			this.footer.style.setProperty('--flowing-footer-overlay-height', availableHeight + 'px');

			// Align horizontally with board where possible (accounts for sidebars)
			try {
				const left = Math.max(8, Math.round(brect.left || 280));
				const right = Math.max(8, Math.round((window.innerWidth || document.documentElement.clientWidth) - (brect.right || (window.innerWidth || 1200))));
				document.documentElement.style.setProperty('--flowing-footer-left', left + 'px');
				document.documentElement.style.setProperty('--flowing-footer-right', right + 'px');
			} catch (e) { /* ignore */ }
		} else {
			// No board available: anchor under header and fill remaining viewport
			const viewportH = (window.innerHeight || document.documentElement.clientHeight || 800);
			const bottomInset = 24;
			const available = Math.max(240, viewportH - topOffset - bottomInset);
			this.footer.style.setProperty('--flowing-footer-overlay-top', topOffset + 'px');
			this.footer.style.setProperty('--flowing-footer-overlay-height', available + 'px');
		}

		// After updating CSS vars that control footer height, allow the
		// browser to reflow and then adjust balanced content sizing so it
		// fills the available footer height (prevents cutting content).
		try {
			setTimeout(() => { try { this.adjustContentPadding(false); } catch (e) { /* ignore */ } }, 50);
		} catch (e) { /* ignore */ }
	} catch(e) { /* ignore */ }
}

	async loadTicketIntoBalancedView(issueKey) {
	console.log('üì• Loading ticket details for:', issueKey);

	const container = document.getElementById('balancedContentContainer');
	if (!container) return;

	// First check if issue exists in state (from app.js)
	let issue = window.state?.issues?.find(i => i.key === issueKey);

	if (!issue) {
		console.warn('‚ö†Ô∏è Issue not found in state, checking issuesCache...');
		// Try from issuesCache (Map)
		if (window.app?.issuesCache) {
			issue = window.app.issuesCache.get(issueKey);
		}
	}

	if (!issue) {
		console.error('‚ùå Issue not found:', issueKey);
		container.innerHTML = `
	<div style="padding:40px;text-align:center;">
		  <p style="color:#ef4444;margin-bottom:16px;">‚ùå Issue not found in current queue</p>
					<button onclick="window._flowingFooter?.public_collapse?.()" style="padding:10px 20px;background:#3b82f6;color:#fff;border:none;border-radius:8px;cursor:pointer;font-weight:600;">
			<i class="fas fa-arrow-left" style="margin-right:8px;"></i> Back
		  </button>
		</div>
	`;
		return;
	}

	// Show loading state
	container.innerHTML = `
	<div style="padding:40px;text-align:center;">
		<div class="loading-spinner" style="border:4px solid #f3f4f6;border-top:4px solid #3b82f6;border-radius:50%;width:40px;height:40px;animation:spin 1s linear infinite;margin:0 auto;"></div>
		<p style="margin-top:16px;color:#6b7280;">Loading complete ticket details...</p>
	  </div>
	`;

	try {
		// Fetch complete details from Service Desk API (same as right-sidebar)
		const response = await fetch(`/api/servicedesk/request/${issueKey}`);

		if (!response.ok) {
			throw new Error(`HTTP ${response.status} `);
		}

		const apiData = await response.json();
		const data = apiData.data || apiData;

		// Merge Service Desk data with existing issue data
		const completeIssue = {
			...issue,
			...data,
			fields: {
				...issue.fields,
				...data.fields
			}
		};

		console.log('‚úÖ Complete issue data loaded:', completeIssue);

		// Render ticket details in balanced view
		this.renderBalancedContent(completeIssue);
		// Ensure attachments module is available (loads module if missing)
		try { await this.ensureAttachmentsModuleLoaded(); } catch (e) { /* ignore */ }
		// Render attachments (single unified renderer handles both right column and footer thumbnails)
		try { await this.renderAttachments(completeIssue); } catch (e) { console.warn('Could not render attachments for balanced view', e); }
		try { this.setupFooterAttachmentButton(); } catch (e) { /* ignore */ }

		// Load comments using the same method as right-sidebar
		this.loadCommentsForBalancedView(issueKey);
		// adjust heights after comments load
		setTimeout(() => this.adjustCommentsHeight(), 120);
		// register a resize listener once so the comments area adapts to viewport/left-section changes
		try {
			if (!this._balancedResizeRegistered) {
				this._balancedResizeRegistered = true;
				window.addEventListener('resize', () => { try { this.adjustCommentsHeight(); } catch (e) { } });
			}
		} catch (e) { /* ignore */ }

		// Initialize SLA Monitor (same as right-sidebar)
		this.initializeSLAMonitor(issueKey);

	} catch (error) {
		console.error('‚ö†Ô∏è Error fetching complete details, using cached data:', error);
		// Fallback: Use cached issue data
		this.renderBalancedContent(issue);
		try { await this.ensureAttachmentsModuleLoaded(); } catch (e) { /* ignore */ }
		try { await this.renderAttachments(issue); } catch (e) { /* ignore */ }
		try { this.setupFooterAttachmentButton(); } catch (e) { /* ignore */ }
		this.loadCommentsForBalancedView(issueKey);
		this.initializeSLAMonitor(issueKey);
	}
}

	async initializeSLAMonitor(issueKey) {
	console.log('‚è±Ô∏è Initializing SLA Monitor for:', issueKey);

	// Prefer the SLA container inside the balanced view to avoid clashing with right-sidebar copies
	const balancedContainer = document.getElementById('balancedContentContainer');
	const slaContainer = (balancedContainer && balancedContainer.querySelector('.right-section .sla-monitor-container')) || (balancedContainer && balancedContainer.querySelector('.sla-monitor-container')) || document.querySelector('.sla-monitor-container');
	if (!slaContainer) {
		console.warn('‚ö†Ô∏è SLA container not found');
		// still render breach risk fallback so user sees a meaningful UI even when SLA panel is missing
		this.renderBreachRisk(issueKey, null);
		return;
	}

	// Check if window.slaMonitor is available
	if (!window.slaMonitor || typeof window.slaMonitor.init !== 'function') {
		console.warn('‚ö†Ô∏è SLA Monitor not available');
		slaContainer.innerHTML = `
				<div style="text-align:center;padding:20px;color:#9ca3af;font-size:12px;">
					<i class="fas fa-info-circle" style="margin-bottom:8px;font-size:16px;"></i><br>
					SLA Monitor not available
				</div>
			`;
		// show breach-risk fallback when SLA module is not present
		this.renderBreachRisk(issueKey, null);
		return;
	}

	try {
		// Initialize SLA Monitor (same as right-sidebar)
		await window.slaMonitor.init(issueKey);

		// Ensure we're listening for async ML predictions and update UI when they arrive
		try {
			this._slaPredictionHandlers = this._slaPredictionHandlers || {};
			if (!this._slaPredictionHandlers[issueKey]) {
				const handler = (ev) => {
					try {
						const det = ev && ev.detail ? ev.detail : null;
						if (!det || det.issueKey !== issueKey) return;
						// When a prediction arrives, prefer the prediction object for breach UI
						try { this.renderBreachRisk(issueKey, det.prediction); } catch (e) { /* ignore */ }
					} catch (e) { /* ignore */ }
				};
				if (typeof window !== 'undefined' && window.addEventListener) window.addEventListener('sla:prediction', handler);
				else if (typeof document !== 'undefined' && document.addEventListener) document.addEventListener('sla:prediction', handler);
				this._slaPredictionHandlers[issueKey] = handler;
			}
		} catch (e) { /* ignore */ }

		// Ask SLA Monitor to fetch prediction (non-blocking)
		try { if (window.slaMonitor && typeof window.slaMonitor.predictBreachAndPublish === 'function') window.slaMonitor.predictBreachAndPublish(issueKey); } catch (e) { /* ignore */ }

		if (window.slaMonitor.slaData && window.slaMonitor.slaData[issueKey]) {
			// Render SLA panel using the existing method
			const slaPanel = window.slaMonitor.renderSLAPanel(issueKey);
			slaContainer.innerHTML = '';
			slaContainer.appendChild(slaPanel);

			// Make the outer container transparent (no white background) but keep subtle shadow for depth
			try {
				slaContainer.style.background = 'transparent';
				slaContainer.style.border = 'none';
				slaContainer.style.borderRadius = '10px';
				// Keep a soft shadow to lift the panel slightly
				slaContainer.style.boxShadow = '0 8px 20px rgba(15, 23, 42, 0.06)';
				// keep padding for spacing
				slaContainer.style.padding = '12px';
			} catch (e) {
				console.warn('Could not set slaContainer transparent:', e);
			}

			// Wait for DOM to be ready before customizing (with retries)
			const attemptCompactAdjust = (attempt = 0) => {
				try {
					let slaPanelElement = slaContainer.querySelector('.sla-panel') || slaContainer.querySelector('.sla-monitor') || slaContainer.querySelector('.sla-cycle');
					if (!slaPanelElement && slaContainer.firstElementChild) slaPanelElement = slaContainer.firstElementChild;
					if (!slaPanelElement) {
						if (attempt < 3) {
							// try again after a small delay
							setTimeout(() => attemptCompactAdjust(attempt + 1), 180);
							return;
						}
						console.warn('‚ö†Ô∏è SLA panel element not found after retries');
						return;
					}

					console.log('üîß Customizing SLA panel layout (attempt', attempt + 1, ')...');
					try { console.log('üìã Panel HTML:', slaPanelElement.innerHTML.substring(0, 200)); } catch (e) { /* ignore */ }

					// Hide "SLA Monitor" title if present (compact header)
					const titleElement = slaPanelElement.querySelector('h3') || slaPanelElement.querySelector('.sla-title');
					if (titleElement) {
						titleElement.style.display = 'none';
						console.log('‚úÖ Hidden title');
					}

					// Move refresh button next to status badge (use SLA monitor's real classes)
					const refreshBtn = slaPanelElement.querySelector('.sla-refresh-btn') || slaPanelElement.querySelector('.refresh-sla-btn') || slaPanelElement.querySelector('.btn-refresh-sla') || slaPanelElement.querySelector('button[onclick*="refresh"]') || Array.from(slaPanelElement.querySelectorAll('button')).find(btn => (btn.textContent || '').toLowerCase().includes('‚Üª') || (btn.textContent || '').toLowerCase().includes('refresh'));

					// Status badge is rendered as .cycle-status inside the SLA panel
					const statusBadge = slaPanelElement.querySelector('.cycle-status') || slaPanelElement.querySelector('.cycle-status.healthy') || Array.from(slaPanelElement.querySelectorAll('[class*="status"]')).find(el => (el.textContent || '').toLowerCase().includes('on track') || (el.textContent || '').toLowerCase().includes('breach') || (el.textContent || '').toLowerCase().includes('breached'));

					console.log('üîç Refresh button:', !!refreshBtn);
					console.log('üîç Status badge:', !!statusBadge);

					if (refreshBtn && statusBadge) {
						// Get the container of the status badge (cycle-header)
						const statusContainer = statusBadge.closest('.cycle-header') || statusBadge.parentElement || slaPanelElement.querySelector('.sla-header') || slaPanelElement;
						if (statusContainer) {
							refreshBtn.style.display = 'inline-flex';
							refreshBtn.style.marginLeft = '8px';
							refreshBtn.style.padding = '6px 10px';
							refreshBtn.style.fontSize = '13px';
							refreshBtn.style.minWidth = '40px';
							refreshBtn.style.height = '30px';
							refreshBtn.style.borderRadius = '6px';
							refreshBtn.style.verticalAlign = 'middle';
							refreshBtn.style.alignItems = 'center';
							refreshBtn.style.justifyContent = 'center';
							refreshBtn.style.border = '1px solid rgba(255,255,255,0.06)';
							// Move the refresh button into the status container
							try { statusContainer.appendChild(refreshBtn); }
							catch (e) { /* ignore */ }
							console.log('‚úÖ Moved refresh button next to status badge');
						}
					}

					// Move "Updated" next to "Remaining" (side-by-side)
					const updatedElement = slaPanelElement.querySelector('.sla-last-updated') || Array.from(slaPanelElement.querySelectorAll('*')).find(el => (el.textContent || '').includes('Updated:'));

					// Find the detail row that contains the 'Remaining' label, then its value
					let remainingValue = null;
					const detailRows = Array.from(slaPanelElement.querySelectorAll('.detail-row'));
					const remainingRow = detailRows.find(row => { const lbl = row.querySelector('.detail-label'); return lbl && /remaining/i.test(lbl.textContent || ''); });
					if (remainingRow) remainingValue = remainingRow.querySelector('.detail-value') || remainingRow.querySelector('span');
					else {
						const found = Array.from(slaPanelElement.querySelectorAll('*')).find(el => /remaining/i.test(el.textContent || ''));
						remainingValue = found;
					}

					console.log('üîç Updated element:', !!updatedElement);
					console.log('üîç Remaining value element:', !!remainingValue);

					if (updatedElement && remainingValue) {
						try {
							updatedElement.style.fontSize = '10px';
							updatedElement.style.color = '#9ca3af';
							updatedElement.style.marginLeft = '8px';
							updatedElement.style.display = 'inline-block';

							// Place updated after the remaining value
							if (remainingValue.parentElement) {
								remainingValue.after(updatedElement);
							}

							console.log('‚úÖ Moved Updated next to Remaining');
						} catch (e) { console.warn('‚ö†Ô∏è Could not move Updated next to Remaining:', e); }
					}

					// Reduce padding for compact view but keep panel visuals (do not override background/border)
					try { slaPanelElement.style.padding = '0'; } catch (e) { /* ignore */ }
					// Mark container to help CSS debugging
					try { slaContainer.classList.add('flowing-sla-compact'); } catch (e) { /* ignore */ }
				} catch (e) {
					console.warn('Error applying compact SLA adjustments', e);
				}
				console.log('‚úÖ SLA Monitor rendered (compact mode)');
			};
			attemptCompactAdjust(0);

			// Calculate and render breach risk
			this.renderBreachRisk(issueKey);

			// Attach footer comment composer handler (balanced view)
			try {
				const footerSend = document.querySelector('.btn-add-comment-footer');
				if (footerSend) {
					footerSend.addEventListener('click', async () => {
						if (window.commentsModule && typeof window.commentsModule.postComment === 'function') {
							await window.commentsModule.postComment(issueKey, {
								textareaSelector: '#footerCommentText',
								internalCheckboxSelector: '#commentInternalFooter',
								listSelector: '.comments-section .comments-list',
								countSelector: '#commentCountFooter',
								buttonSelector: '.btn-add-comment-footer',
								visibilityLabelSelector: '.visibility-label-footer'
							});
						} else {
							console.warn('commentsModule.postComment not available');
						}
					});
				}
				// Attach mentions autocomplete to footer textarea (balanced view)
				try {
					const footerTextarea = document.getElementById('footerCommentText');
					if (footerTextarea) {
						const attachMentions = async () => {
							if (window.mentionsAutocomplete && typeof window.mentionsAutocomplete.attachTo === 'function') {
								window.mentionsAutocomplete.attachTo(footerTextarea, issueKey);
								console.log('‚úÖ Attached mentionsAutocomplete to footer textarea');
								return;
							}
							// Load module dynamically if missing
							try {
								await new Promise((resolve, reject) => {
									const s = document.createElement('script');
									s.src = '/static/js/modules/mentions-autocomplete.js?v=' + Date.now();
									s.onload = resolve;
									s.onerror = reject;
									document.head.appendChild(s);
								});
								if (window.mentionsAutocomplete && typeof window.mentionsAutocomplete.attachTo === 'function') {
									window.mentionsAutocomplete.attachTo(footerTextarea, issueKey);
									console.log('‚úÖ Dynamically loaded and attached mentionsAutocomplete to footer textarea');
								}
							} catch (err) {
								console.warn('‚ö†Ô∏è Failed to load mentions-autocomplete for footer:', err);
							}
						};
						// Small timeout to allow DOM and module init
						setTimeout(attachMentions, 80);

						// Shortcut: Ctrl/Cmd+Enter to send from footer
						footerTextarea.addEventListener('keydown', (e) => {
							if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
								e.preventDefault();
								document.querySelector('.btn-add-comment-footer')?.click();
							}
						});
					}
				} catch (err) {
					console.warn('Could not attach mentions to footer textarea', err);
				}
			} catch (e) {
				console.warn('Could not attach footer comment handler', e);
			}
		} else {
			slaContainer.innerHTML = `
		  <div style="text-align:center;padding:16px;color:#9ca3af;font-size:11px;">
			<i class="fas fa-check-circle" style="margin-bottom:6px;font-size:14px;color:#10b981;"></i><br>
			No active SLA
		  </div>
		`;

			// Ensure right-section occupies its grid cell even if global CSS applies restrictive rules
			try {
				// Use the balanced container (may be outside of this function scope)
				const right = balancedContainer?.querySelector('.right-section');
				const left = balancedContainer?.querySelector('.left-section');
				if (right) {
					right.style.flex = '1 1 auto';
					right.style.maxWidth = 'none';
					right.style.width = 'auto';
					right.style.minWidth = '0';
					right.style.boxSizing = 'border-box';
				}
				if (left) {
					left.style.flex = '1 1 50%';
					left.style.minWidth = '0';
					left.style.boxSizing = 'border-box';
				}
			} catch (e) { console.warn('Could not enforce balanced sections inline styles', e); }

			// Show no risk if no SLA
			this.renderBreachRisk(issueKey, null);
		}
	} catch (error) {
		console.error('‚ùå Error initializing SLA Monitor:', error);
		slaContainer.innerHTML = `
	<div style="text-align:center;padding:16px;color:#ef4444;font-size:11px;">Failed to load SLA</div>
	`;
	}
}

renderBreachRisk(issueKey, slaData = null) {
	// Prefer the breach container inside the balanced view to avoid colliding with other instances
	const balancedContainer = document.getElementById('balancedContentContainer');
	const riskContainer = (balancedContainer && balancedContainer.querySelector('.right-section .breach-risk-content')) || (balancedContainer && balancedContainer.querySelector('.breach-risk-content')) || document.querySelector('.breach-risk-content');
	if (!riskContainer) return;

	// Get SLA data from window.slaMonitor (support multiple data shapes)
	const data = slaData || window.slaMonitor?.slaData?.[issueKey] || null;

	if (!data) {
		riskContainer.innerHTML = `
			<div style="display:flex;align-items:center;gap:12px;padding:12px;">
				<div style="width:50px;height:50px;border-radius:50%;background:rgba(16,185,129,0.1);display:flex;align-items:center;justify-content:center;flex-shrink:0;">
					${typeof SVGIcons !== 'undefined' && SVGIcons.success ? SVGIcons.success({ size: 20, className: 'inline-icon' }) : '‚úì'}
				</div>
				<div style="flex:1;">
					<p style="font-size:11px;color:#10b981;font-weight:600;margin:0;">LOW RISK</p>
					<p style="font-size:9px;color:#9ca3af;margin:2px 0 0 0;">No active SLA</p>
				</div>
			</div>
			`;
		return;
	}

	// Normalize to a 'cycle' object (supports: ongoingCycle, cycles[0], or data shaped as a cycle)
	const cycle = data.ongoingCycle || (Array.isArray(data.cycles) && data.cycles[0]) || data;

	// Helper: parse human readable times ("2 h 30 m", "45 m", "Overdue") to milliseconds
	const parseReadableToMillis = (s) => {
		if (!s) return 0;
		try {
			const str = String(s).toLowerCase();
			if (/overdue|n\/a|na|unknown|breached/.test(str)) return 0;
			let mins = 0;
			const dayMatch = str.match(/(\d+)\s*d/);
			if (dayMatch) mins += parseInt(dayMatch[1], 10) * 24 * 60;
			const hourMatch = str.match(/(\d+)\s*h/);
			if (hourMatch) mins += parseInt(hourMatch[1], 10) * 60;
			const minuteMatch = str.match(/(\d+)\s*m/);
			if (minuteMatch) mins += parseInt(minuteMatch[1], 10);
			if (mins === 0) {
				const numOnly = str.match(/(\d+)/);
				if (numOnly) mins = parseInt(numOnly[1], 10);
			}
			return mins * 60 * 1000;
		} catch (e) { return 0; }
	};

	const parseTimeToMillis = (v) => {
		if (!v && v !== 0) return 0;
		try {
			if (typeof v === 'number') return Number(v);
			if (typeof v === 'string') return parseReadableToMillis(v);
			if (typeof v === 'object') {
				if (v.millis !== undefined && v.millis !== null) return Number(v.millis) || 0;
				if (v.ms !== undefined && v.ms !== null) return Number(v.ms) || 0;
				// friendly/readable fields
				const candidate = v.readable || v.friendly || v.value || v.text || v.display || '';
				if (candidate) return parseReadableToMillis(candidate);
			}
		} catch (e) { /* ignore */ }
		return 0;
	};

	// Obtain elapsed and remaining in milliseconds using flexible mapping
	const elapsed = parseTimeToMillis(cycle.elapsedTime || cycle.elapsed_time || cycle.elapsed || cycle.elapsed_time_readable || cycle.elapsed_time_readable);
	const remaining = parseTimeToMillis(cycle.remainingTime || cycle.remaining_time || cycle.remaining || cycle.remaining_time_readable || cycle.remaining_time_readable);
	const total = (elapsed + remaining) || 1;
	const percentage = Math.round((elapsed / total) * 100);

	console.log('üîé renderBreachRisk debug', { issueKey, cyclePreview: { elapsed, remaining, total, percentage }, cycleSample: cycle });

	// Determine risk level
	let riskLevel, riskColor, riskIcon, riskBg;
	if (percentage >= 90) {
		riskLevel = 'CRITICAL';
		riskColor = '#ef4444';
		riskBg = 'rgba(239, 68, 68, 0.1)';
		riskIcon = 'fa-exclamation-triangle';
	} else if (percentage >= 75) {
		riskLevel = 'HIGH';
		riskColor = '#f59e0b';
		riskBg = 'rgba(245, 158, 11, 0.1)';
		riskIcon = 'fa-exclamation-circle';
	} else if (percentage >= 50) {
		riskLevel = 'MEDIUM';
		riskColor = '#4f46e5';
		riskBg = 'rgba(79, 70, 229, 0.1)';
		riskIcon = 'fa-exclamation-triangle';
	} else {
		riskLevel = 'LOW';
		riskColor = '#10b981';
		riskBg = 'rgba(16, 185, 129, 0.1)';
		riskIcon = 'fa-check';
	}

	// Build SVG icon for the risk badge using SVGIcons (fallback to emoji)
	let iconSVG = '';
	try {
		if (typeof SVGIcons !== 'undefined') {
			if (riskLevel === 'CRITICAL') iconSVG = SVGIcons.error ? SVGIcons.error({ size: 16, className: 'inline-icon' }) : SVGIcons.xCircle ? SVGIcons.xCircle({ size: 16, className: 'inline-icon' }) : '‚ùå';
			else if (riskLevel === 'HIGH') iconSVG = SVGIcons.alert ? SVGIcons.alert({ size: 16, className: 'inline-icon' }) : '‚ö†Ô∏è';
			else if (riskLevel === 'MEDIUM') iconSVG = SVGIcons.alert ? SVGIcons.alert({ size: 16, className: 'inline-icon' }) : '‚ö†Ô∏è';
			else iconSVG = SVGIcons.success ? SVGIcons.success({ size: 16, className: 'inline-icon' }) : '‚úì';
		} else {
			iconSVG = (riskLevel === 'CRITICAL' ? '‚ùå' : (riskLevel === 'HIGH' ? '‚ö†Ô∏è' : (riskLevel === 'MEDIUM' ? '‚ö†Ô∏è' : '‚úì')));
		}
	} catch (e) { iconSVG = (riskLevel === 'CRITICAL' ? '‚ùå' : (riskLevel === 'HIGH' ? '‚ö†Ô∏è' : (riskLevel === 'MEDIUM' ? '‚ö†Ô∏è' : '‚úì'))); }

	// Compact mode: show as badge (initial state) using class-based markup so CSS can style it
	const compactHTML = `
			<div class="breach-risk-compact">
				<div class="breach-risk-icon" aria-hidden="true">${iconSVG}</div>
				<div class="breach-risk-label">${riskLevel}</div>
			</div>
		`;

	// Expanded mode: detailed panel
	const expandedHTML = `
			<div class="breach-risk-expanded">
				<div class="breach-risk-main">
					<div class="breach-risk-icon-large" aria-hidden="true">${iconSVG}</div>
					<div class="breach-risk-details">
						<div class="breach-risk-title">Breach Risk</div>
						<div class="breach-risk-times">
							<div class="br-row"><span>Elapsed:</span><span>${(cycle.elapsedTime?.readable || cycle.elapsedTime || cycle.elapsed_time) || 'N/A'}</span></div>
							<div class="br-row"><span>Remaining:</span><span class="${percentage >= 75 ? 'risk-warning' : ''}">${(cycle.remainingTime?.readable || cycle.remainingTime || cycle.remaining_time) || 'N/A'}</span></div>
							${percentage >= 75 ? `<div class="br-warning" style="color:${riskColor};font-weight:600;">${SVGIcons.alert ? SVGIcons.alert({ size: 12, className: 'inline-icon' }) : ''} Near deadline ‚Äî attention recommended</div>` : ''}
						</div>
					</div>
				</div>
				<div class="breach-risk-percentage">${percentage}%</div>
			</div>
		`;

	// Ensure the risk container fills available width and show compact badge by default
	try { riskContainer.style.width = '100%'; } catch (e) { /* ignore */ }
	// Expose color/background as CSS variables so styles can be themed in CSS
	try { riskContainer.style.setProperty('--breach-color', riskColor); riskContainer.style.setProperty('--breach-bg', riskBg); riskContainer.style.setProperty('--breach-percentage-bg', riskBg); } catch (e) { /* ignore */ }
	riskContainer.classList.remove('expanded');
	riskContainer.innerHTML = compactHTML;
	riskContainer.style.cursor = 'pointer';
	// Toggle expanded/compact on click
	riskContainer.onclick = () => {
		const expanded = riskContainer.classList.toggle('expanded');
		riskContainer.innerHTML = expanded ? expandedHTML : compactHTML;
	};
}

	async loadCommentsForBalancedView(issueKey) {
	// Ensure comments module is loaded: dynamically load if missing
	if (!window.commentsModule || typeof window.commentsModule.loadIssueComments !== 'function') {
		try {
			await new Promise((resolve, reject) => {
				const script = document.createElement('script');
				script.src = '/static/js/modules/comments.js?v=' + Date.now();
				script.onload = () => resolve();
				script.onerror = (e) => reject(e);
				document.head.appendChild(script);
			});
		} catch (e) {
			console.warn('Could not dynamically load comments module:', e);
		}
	}

	if (window.commentsModule && typeof window.commentsModule.loadIssueComments === 'function') {
		return window.commentsModule.loadIssueComments(issueKey, { listSelector: '.comments-section .comments-list', countSelector: '#commentCountFooter', order: 'desc' });
	}

	// Final fallback: show unavailable message
	const commentsContainer = document.querySelector('.comments-section .comments-list');
	if (commentsContainer) commentsContainer.innerHTML = '<p style="text-align: center; padding: 20px; color: #9ca3af; font-size: 12px;">Comments unavailable</p>';
}

// After rendering balanced content, adjust comments container height to match left column
adjustCommentsHeight() {
	try {
		const container = document.getElementById('balancedContentContainer');
		if (!container) return;
		const leftCol = container.querySelector('.left-section');
		const rightCol = container.querySelector('.right-section');
		if (!leftCol || !rightCol) return;
		const commentsSection = rightCol.querySelector('.comments-section');
		const composer = rightCol.querySelector('.comment-composer');
		if (!commentsSection) return;

		// Compute available height for comments based on the footer's
		// rendered height (preferred) and fall back to the left column's
		// height. Reserve space for the header and composer.
		const paddingReserve = 16; // breathing room
		const MIN_COMMENT_HEIGHT = 120; // preferred minimum for comments area

		const leftHeight = leftCol.getBoundingClientRect().height;
		const composerHeight = composer ? composer.getBoundingClientRect().height : 0;

		// Try to base sizing on the actual footer's height so comments
		// can expand to the maximum available area inside the footer.
		let footerInner = null;
		try {
			const footerRect = (this.footer && typeof this.footer.getBoundingClientRect === 'function') ? this.footer.getBoundingClientRect() : null;
			if (footerRect && footerRect.height > 0) {
				const headerEl = document.getElementById('flowingHeader') || (this.footer && this.footer.querySelector('.flowing-header'));
				const headerH = (headerEl && typeof headerEl.getBoundingClientRect === 'function') ? Math.round(headerEl.getBoundingClientRect().height) : 72;
				footerInner = Math.max(120, Math.floor(footerRect.height - headerH - paddingReserve));
			}
		} catch (e) { footerInner = null; }

		// Preferred available height: use footerInner if present, otherwise left column
		let available = Math.floor((footerInner !== null ? footerInner : leftHeight) - composerHeight - paddingReserve);
		// Never allow negative/too-small heights
		if (!Number.isFinite(available) || available < 120) available = 120;

		// computedMax should reflect the maximal usable height for comments
		const computedMax = Math.max(MIN_COMMENT_HEIGHT, available);
		const computedMin = Math.min(MIN_COMMENT_HEIGHT, computedMax);

		// Set explicit height so comments fill the available footer area
		commentsSection.style.maxHeight = `${computedMax}px`;
		commentsSection.style.height = `${computedMax}px`;
		commentsSection.style.minHeight = `${computedMin}px`;
		commentsSection.style.overflowY = 'auto';

		// Also ensure comments list scrolls newest-first properly
		const list = commentsSection.querySelector('.comments-list');
		if (list) {
			const nearBottom = (list.scrollHeight - list.clientHeight - list.scrollTop) < 100;
			if (nearBottom) list.scrollTop = list.scrollHeight;
		}

		console.log('üîß Adjusted commentsSection size to', { min: computedMin, max: computedMax });
	} catch (e) {
		console.warn('Could not adjust comments height:', e);
	}
}

// Helper: delegate attachments DOM creation to attachments module when available
buildAttachmentsHTML(issue, opts = {}) {
	// Prefer the centralized attachments module when available
	try {
		if (window.attachmentsModule && typeof window.attachmentsModule.buildAttachmentsHTML === 'function') {
			return window.attachmentsModule.buildAttachmentsHTML(issue, opts);
		}
	} catch (e) {
		console.warn('attachmentsModule.buildAttachmentsHTML failed', e);
	}

	// When attachmentsModule is not loaded, build DOM nodes directly from real issue data
	try {
		const includeItems = opts.includeItems !== false;
		const includeThumbs = opts.includeThumbs !== false;

		const attachments = (issue && (issue.fields?.attachment || issue.attachments || issue.serviceDesk?.requestFieldValues?.attachments)) || [];
		const frag = includeItems ? document.createDocumentFragment() : null;
		const thumbFrag = includeThumbs ? document.createDocumentFragment() : null;
		const items = [];
		const thumbs = [];

		if (!attachments || attachments.length === 0) return { frag, thumbFrag, items, thumbs, hash: '' };

		const idList = [];
		const seen = new Set();
		attachments.forEach(att => {
			const url = att.content || att.self || att.url || (att.id ? `/api/issues/${issue.key}/attachments/${att.id}` : '') || '';
			const filename = att.filename || att.name || att.displayName || 'attachment';
			const idKey = String(url || filename).trim();
			if (!idKey || seen.has(idKey)) return;
			seen.add(idKey);
			idList.push(idKey);

			const isImage = /\.(png|jpe?g|gif|webp|svg)$/i.test(filename) || (att.mimeType && String(att.mimeType).startsWith('image/')) || /\.(png|jpe?g|gif|webp|svg)$/i.test(String(url || ''));

			if (includeItems) {
				const item = document.createElement('div');
				item.className = 'attachment-item';
				if (isImage) {
					const aThumb = document.createElement('a');
					aThumb.className = 'attachment-thumb'; aThumb.href = url; aThumb.target = '_blank'; aThumb.rel = 'noopener noreferrer';
					const img = document.createElement('img'); img.src = url; img.alt = filename; img.style.maxWidth = '120px'; img.style.maxHeight = '90px'; img.style.borderRadius = '6px'; img.style.display = 'block';
					aThumb.appendChild(img);
					item.appendChild(aThumb);
					const meta = document.createElement('div'); meta.style.display = 'flex'; meta.style.gap = '6px'; meta.style.alignItems = 'center'; meta.style.marginTop = '6px';
					const link = document.createElement('a'); link.className = 'attachment-link'; link.href = url; link.target = '_blank'; link.rel = 'noopener noreferrer'; link.download = ''; link.textContent = filename; meta.appendChild(link);
					const dl = document.createElement('a'); dl.className = 'attachment-download-btn'; dl.href = url; dl.target = '_blank'; dl.rel = 'noopener noreferrer'; dl.download = ''; dl.title = 'Download'; dl.style.textDecoration = 'none'; dl.textContent = '‚¨á';
					meta.appendChild(dl); item.appendChild(meta);
				} else {
					const link = document.createElement('a'); link.className = 'attachment-link'; link.href = url; link.target = '_blank'; link.rel = 'noopener noreferrer'; link.textContent = filename; item.appendChild(link);
					const dl = document.createElement('a'); dl.className = 'attachment-download-btn'; dl.href = url; dl.target = '_blank'; dl.rel = 'noopener noreferrer'; dl.download = ''; dl.title = 'Download'; dl.style.marginLeft = '6px'; dl.style.textDecoration = 'none'; dl.textContent = '‚¨á'; item.appendChild(dl);
				}
				items.push(item);
				if (frag) frag.appendChild(item);
			}

			if (includeThumbs) {
				if (isImage) {
					const t = document.createElement('img');
					t.className = 'attachment-thumb-compact'; t.title = filename; t.src = url; t.style.width = '48px'; t.style.height = '36px'; t.style.objectFit = 'cover'; t.style.borderRadius = '6px'; t.style.cursor = 'pointer'; t.addEventListener('click', () => window.open(url, '_blank'));
					thumbs.push(t); if (thumbFrag) thumbFrag.appendChild(t);
				} else {
					const short = filename.length > 10 ? filename.slice(0, 8) + '‚Ä¶' : filename;
					const t = document.createElement('div'); t.className = 'attachment-thumb-compact'; t.title = filename; t.style.minWidth = '40px'; t.style.height = '30px'; t.style.borderRadius = '6px'; t.style.display = 'inline-flex'; t.style.alignItems = 'center'; t.style.justifyContent = 'center'; t.style.padding = '4px'; t.style.background = '#f3f4f6'; t.style.color = '#374151'; t.style.fontSize = '11px'; t.style.cursor = 'pointer'; t.textContent = short; t.addEventListener('click', () => window.open(url, '_blank'));
					thumbs.push(t); if (thumbFrag) thumbFrag.appendChild(t);
				}
			}
		});

		const hash = idList.join('|');
		return { frag, thumbFrag, items, thumbs, hash };
	} catch (e) {
		console.warn('buildAttachmentsHTML fallback error', e);
		const frag = document.createDocumentFragment();
		const thumbFrag = document.createDocumentFragment();
		return { frag, thumbFrag, items: [], thumbs: [], hash: '' };
	}
}

// Internal helper: clear all children of an element
_clearChildren(el) {
	if (!el) return;
	while (el.firstChild) el.removeChild(el.firstChild);
}

// Internal helper: append a DocumentFragment or array/collection of nodes
_appendNodesOrFragment(target, nodesOrFrag) {
	if (!target || !nodesOrFrag) return;
	try {
		if (nodesOrFrag instanceof DocumentFragment) {
			target.appendChild(nodesOrFrag);
			return;
		}
		if (Array.isArray(nodesOrFrag)) {
			nodesOrFrag.forEach(n => {
				try { target.appendChild(n.cloneNode ? n.cloneNode(true) : n); } catch (e) { /* ignore */ }
			});
			return;
		}
		// NodeList / HTMLCollection / other array-like
		if (typeof nodesOrFrag.length === 'number' && nodesOrFrag[0]) {
			for (let i = 0; i < nodesOrFrag.length; i++) {
				try { target.appendChild(nodesOrFrag[i].cloneNode ? nodesOrFrag[i].cloneNode(true) : nodesOrFrag[i]); } catch (e) { /* ignore */ }
			}
			return;
		}
		// Single Node
		if (nodesOrFrag.nodeType) {
			target.appendChild(nodesOrFrag.cloneNode ? nodesOrFrag.cloneNode(true) : nodesOrFrag);
		}
	} catch (e) { /* ignore */ }
}
	// Unified attachments renderer: handles both right-column full items and footer thumbnails.
	async renderAttachments(issue) {
	try {
		// Treat right column and footer as the same component: render once into the canonical container
		const container = document.getElementById('attachmentsListRight') || document.getElementById('attachmentsListFooter') || document.getElementById('attachmentsListHeader');
		const attachmentsPreview = document.getElementById('attachmentsPreviewFooter');
		if (!container) return;

		// Prefer attachmentsModule when available (it handles caching/dedupe)
		if (window.attachmentsModule && typeof window.attachmentsModule.renderFullItemsInto === 'function') {
			try {
				const res = await window.attachmentsModule.renderFullItemsInto(container, issue);
				if (attachmentsPreview) {
					if (res && res.rendered) attachmentsPreview.classList.add('show'); else attachmentsPreview.classList.remove('show');
				}
				return;
			} catch (err) {
				// Strict fallback policy: do NOT fall back to local rendering when the
				// attachmentsModule exists but failed. The attachments module is the
				// authoritative renderer; if it errors, we clear the container and
				// surface a warning so model-dependent fallbacks are not used
				// inadvertently. Fallbacks should only be used when the module is
				// absent (e.g., older pages) or when explicitly required for model
				// generated content.
				console.warn('attachmentsModule.renderFullItemsInto failed ‚Äî not falling back per policy', err);
				try { this._clearChildren(container); } catch (e) { /* ignore */ }
				if (attachmentsPreview && attachmentsPreview.classList && typeof attachmentsPreview.classList.remove === 'function') attachmentsPreview.classList.remove('show');
				return;
			}
		}

		// Fallback: only used when attachmentsModule is NOT present (use real issue data)
		const { frag, items } = this.buildAttachmentsHTML(issue, { includeItems: true, includeThumbs: true });
		if ((!items || items.length === 0)) {
			this._clearChildren(container);
			if (attachmentsPreview && attachmentsPreview.classList && typeof attachmentsPreview.classList.remove === 'function') attachmentsPreview.classList.remove('show');
			return;
		}

		this._clearChildren(container);
		if (frag && frag.childNodes && frag.childNodes.length) this._appendNodesOrFragment(container, frag);
		else this._appendNodesOrFragment(container, items);
		if (attachmentsPreview && attachmentsPreview.classList && typeof attachmentsPreview.classList.add === 'function') attachmentsPreview.classList.add('show');
	} catch (e) {
		console.warn('renderAttachments error', e);
	}
}

// Show a confirmation banner in the footer header for applying small field recommendations
showFieldRecommendationBanner(fieldKey, fieldLabel, suggestedValue, meta = {}) {
	try {
		const container = document.getElementById('balancedContentContainer');
		if (!container) return;
		// remove existing banner
		const existing = document.getElementById('flowingRecBanner');
		if (existing) {
			if (typeof existing.remove === 'function') existing.remove();
			else if (existing.parentNode) existing.parentNode.removeChild(existing);
		}

		const banner = document.createElement('div');
		banner.id = 'flowingRecBanner';
		banner.style.cssText = 'position:relative;margin:8px 0;padding:12px;border-radius:8px;background:linear-gradient(90deg,#fff,#f8fafc);border:1px solid #e6e6f0;display:flex;align-items:center;gap:12px;';

